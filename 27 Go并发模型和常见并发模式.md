### 并发模型


原则：不要通过共享内存来通信，而应该通过通信来共享内存 - Rob Pike，Go 语言之父

这句话的表现可以看channel的底层，channel底层有一个buffer存储数据的，其实这个buffer并不会被多个线程共享，而是有一个队列，a线程获取b线程存储在chan的buffer数据，是按队列的形式输出a线程存储的数据给b线程

```
//G1
func main(){
    ...

    for _, task := range hellaTasks {
        ch <- task    //sender
    }

    ...
}

//G2
func worker(ch chan Task){
    for {
       //接受任务
       task := <- ch  //recevier
       process(task)
    }
}
```

比如这一块，G1 和 G2 其实并没有共享内存，而是通过 ch 通信的形式 （虽然同一个ch都被G1 和 G2 共享，但是并没有主动去访问ch内的值，而是让ch作为一个消息媒介，主动地消息发送接收从而让 G1 和 G2共享一个值）


### 传统语言的并发模型是基于对内存的共享的

简而言之，就是创建一个变量，可以给多个线程使用，通过加锁的方式实现线程安全，多线程之间通信的基础是基于共享的内存；

那么会有什么弊端呢？

1. 锁就涉及有可能带来死锁 - 将锁的加锁解锁交给了各个线程

2. 



###  CSP(Communicationing Sequential Processes，通信顺序进程) 并发模型


